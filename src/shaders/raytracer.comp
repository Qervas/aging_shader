#version 430

#include "common/constants.glsl"
#include "common/structures.glsl"
#include "common/utils.glsl"
#include "common/noise.glsl"
#include "common/uniforms.glsl"
#include "materials/brdf.glsl"
#include "materials/material_library.glsl"
#include "intersect/ray.glsl"
#include "intersect/primitives.glsl"

layout(local_size_x = 8, local_size_y = 8) in;
layout(rgba32f, binding = 0) uniform image2D outputImage;
layout(std430, binding = 0) buffer ObjectBuffer {
    vec4 objectData[]; // position + type
};

Sphere sphere = Sphere(
        vec3(0.0), // center
        1.0, // radius
        createBasicMaterial(
            STEEL_COLOR, // albedo
            1.0, // metallic
            0.1, // roughness
            2.5, // IOR
            vec3(0.0, 0.0, 1.0) // default normal
        )
    );

Rectangle painting = Rectangle(
        vec3(0.0, 0.0, -5.0), // center
        vec3(0.0, 0.0, 1.0), // normal
        vec3(0.0, 1.0, 0.0), // up
        2.0, // width
        1.5, // height
        createBasicMaterial( // default material
            vec3(1.0), // albedo
            0.0, // metallic
            0.5, // roughness
            1.5, // IOR
            vec3(0.0, 0.0, 1.0) // normal
        )
    );
vec3 trace(Ray ray) {
    HitInfo closestHit;
    closestHit.hit = false;
    closestHit.t = 1e30;

    // Test each object and keep track of the closest intersection
    for (int i = 0; i < numObjects; i++) {
        vec4 objData = objectData[i];
        vec3 objPos = objData.xyz;
        int objType = int(objData.w);

        HitInfo currentHit;

        if (objType == 0) { // SPHERE
            Sphere currentSphere = Sphere(objPos, 1.0, sphere.material);
            if (intersectSphere(ray, currentSphere, rustLevel, currentHit)) {
                if (!closestHit.hit || currentHit.t < closestHit.t) {
                    closestHit = currentHit;
                }
            }
        }
        else if (objType == 1) { // RECTANGLE
            Rectangle currentRect = Rectangle(objPos, painting.normal, painting.up,
                    painting.width, painting.height, painting.material);
            if (intersectRectangle(ray, currentRect, currentHit)) {
                if (!closestHit.hit || currentHit.t < closestHit.t) {
                    closestHit = currentHit;
                }
            }
        }
        else if (objType == 2) { // GROUND
            if (intersectGround(ray, currentHit)) {
                if (!closestHit.hit || currentHit.t < closestHit.t) {
                    closestHit = currentHit;
                }
            }
        }
    }

    if (closestHit.hit) {
        return tonemap(calculatePBR(closestHit, ray.direction));
    }

    float t = 0.5 * (normalize(ray.direction).y + 1.0);
    return mix(vec3(1.0), SKY_COLOR, t);
}

void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 image_size = imageSize(outputImage);

    if (pixel_coords.x >= image_size.x || pixel_coords.y >= image_size.y) {
        return;
    }

    vec2 uv = (vec2(pixel_coords) + 0.5) / vec2(image_size);
    uv = uv * 2.0 - 1.0;
    uv.x *= float(image_size.x) / float(image_size.y);
    vec3 right = normalize(cross(cameraFront, cameraUp));
    vec3 up = normalize(cross(right, cameraFront));

    vec3 rayDir = normalize(cameraFront +
                uv.x * right * tan(radians(45.0)) +
                uv.y * up * tan(radians(45.0)));

    Ray ray = createRay(cameraPosition, rayDir);

    vec3 color = trace(ray);

    imageStore(outputImage, pixel_coords, vec4(color, 1.0));
}
