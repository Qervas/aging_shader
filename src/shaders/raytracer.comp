#version 430

layout(local_size_x = 8, local_size_y = 8) in;
layout(rgba32f, binding = 0) uniform image2D outputImage;

struct Sphere {
    vec3 center;
    float radius;
    vec3 color;
    float metallic;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

// Scene constants
const vec3 LIGHT_DIR = normalize(vec3(1.0, 1.0, 1.0));
const vec3 SKY_COLOR = vec3(0.5, 0.7, 1.0);
const float GROUND_Y = -1.0;

// Scene objects
const Sphere sphere = Sphere(
    vec3(0.0, 0.0, -5.0),  // center
    1.0,                    // radius
    vec3(0.8, 0.8, 0.8),   // color
    0.9                     // metallic
);

bool intersectSphere(Ray ray, Sphere sphere, out float t, out vec3 normal) {
    vec3 oc = ray.origin - sphere.center;
    float a = dot(ray.direction, ray.direction);
    float b = 2.0 * dot(oc, ray.direction);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;
    float discriminant = b * b - 4.0 * a * c;

    if (discriminant < 0.0) return false;

    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);
    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);

    t = t1 < t2 ? t1 : t2;
    if (t < 0.0) return false;

    vec3 hitPoint = ray.origin + t * ray.direction;
    normal = normalize(hitPoint - sphere.center);
    return true;
}

bool intersectGround(Ray ray, out float t, out vec3 normal) {
    if (ray.direction.y >= 0.0) return false;

    t = -(ray.origin.y - GROUND_Y) / ray.direction.y;
    if (t < 0.0) return false;

    normal = vec3(0.0, 1.0, 0.0);
    return true;
}

vec3 trace(Ray ray) {
    float t, closest_t = 1e30;
    vec3 normal, hit_normal;
    vec3 color = SKY_COLOR;
    bool hit = false;

    // Check sphere intersection
    if (intersectSphere(ray, sphere, t, normal)) {
        if (t < closest_t) {
            closest_t = t;
            hit_normal = normal;
            color = sphere.color;
            hit = true;
        }
    }

    // Check ground intersection
    if (intersectGround(ray, t, normal)) {
        if (t < closest_t) {
            closest_t = t;
            hit_normal = normal;
            color = vec3(0.3, 0.3, 0.3); // Ground color
            hit = true;
        }
    }

    if (hit) {
        float diffuse = max(dot(hit_normal, LIGHT_DIR), 0.0);
        color *= diffuse;
    }

    return color;
}

void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 image_size = imageSize(outputImage);

    if (pixel_coords.x >= image_size.x || pixel_coords.y >= image_size.y) {
        return;
    }

    vec2 uv = (vec2(pixel_coords) + 0.5) / vec2(image_size);
    uv = uv * 2.0 - 1.0;
    uv.x *= float(image_size.x) / float(image_size.y);

    Ray ray;
    ray.origin = vec3(0.0, 0.0, 3.0);
    ray.direction = normalize(vec3(uv.x, uv.y, -1.0));

    vec3 color = trace(ray);

    imageStore(outputImage, pixel_coords, vec4(color, 1.0));
}
