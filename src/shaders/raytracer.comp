#version 430

#include "common/constants.glsl"
#include "common/structures.glsl"
#include "common/utils.glsl"
#include "common/noise.glsl"
#include "common/uniforms.glsl"
#include "materials/brdf.glsl"
#include "materials/material_library.glsl"
#include "intersect/ray.glsl"
#include "intersect/primitives.glsl"

layout(local_size_x = 8, local_size_y = 8) in;
layout(rgba32f, binding = 0) uniform image2D outputImage;

uniform vec3 spherePosition;
uniform float rustLevel;

Sphere sphere = Sphere(
        spherePosition, // center
        1.0, // radius
        createBasicMaterial(
            STEEL_COLOR, // albedo
            1.0, // metallic
            0.1, // roughness
            2.5, // IOR
            vec3(0.0, 0.0, 1.0) // default normal
        )
    );

Rectangle painting = Rectangle(
        vec3(0.0, 0.0, -5.0), // center
        vec3(0.0, 0.0, 1.0), // normal
        vec3(0.0, 1.0, 0.0), // up
        2.0, // width
        1.5, // height
        createBasicMaterial( // default material
            vec3(1.0), // albedo
            0.0, // metallic
            0.5, // roughness
            1.5, // IOR
            vec3(0.0, 0.0, 1.0) // normal
        )
    );
vec3 trace(Ray ray) {
    HitInfo hitInfo;
    hitInfo.hit = false;

    HitInfo paintingHit;
    if (intersectRectangle(ray, painting, paintingHit)) {
        if (!hitInfo.hit || paintingHit.t < hitInfo.t) {
            hitInfo = paintingHit;
        }
    }

    HitInfo sphereHit;
    if (intersectSphere(ray, sphere, rustLevel, sphereHit)) {
        hitInfo = sphereHit;
    }

    HitInfo groundHit;
    if (intersectGround(ray, groundHit)) {
        if (!hitInfo.hit || groundHit.t < hitInfo.t) {
            hitInfo = groundHit;
        }
    }

    if (hitInfo.hit) {
        return tonemap(calculatePBR(hitInfo, ray.direction));
    }

    float t = 0.5 * (normalize(ray.direction).y + 1.0);
    return mix(vec3(1.0), SKY_COLOR, t);
}

void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 image_size = imageSize(outputImage);

    if (pixel_coords.x >= image_size.x || pixel_coords.y >= image_size.y) {
        return;
    }

    vec2 uv = (vec2(pixel_coords) + 0.5) / vec2(image_size);
    uv = uv * 2.0 - 1.0;
    uv.x *= float(image_size.x) / float(image_size.y);

    Ray ray = createRay(
            vec3(0.0, 0.0, 3.0),
            vec3(uv.x, uv.y, -1.0)
        );

    vec3 color = trace(ray);

    imageStore(outputImage, pixel_coords, vec4(color, 1.0));
}
